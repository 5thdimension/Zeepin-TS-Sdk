{"remainingRequest":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js??ref--13-2!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\key.ts","dependencies":[{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\key.ts","mtime":1601302458189},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _classCallCheck from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport * as cryptoJS from 'crypto-js';\nimport { sha3_224, sha3_256, sha3_384, sha3_512 } from 'js-sha3';\nimport { hexstring2ab } from \"../common/functionsUtils\";\nimport { KeyType, KeyParameters } from \"./cryptoParams\";\nimport { SignatureScheme } from \"./cryptoParams\";\nimport { DEFAULT_ALGORITHM } from \"../common/consts\";\n/**\r\n * Common representation of private or public key\r\n */\n\nexport var Key =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Creates Key.\r\n   *\r\n   * If no algorithm or parameters are specified, default values will be used.\r\n   *\r\n   * @param key Hex encoded key value\r\n   * @param algorithm Key type\r\n   * @param parameters Parameters of the key type\r\n   */\n  function Key(key, algorithm, parameters) {\n    _classCallCheck(this, Key);\n\n    this.key = key;\n\n    if (algorithm === undefined) {\n      algorithm = KeyType.fromLabel(DEFAULT_ALGORITHM.algorithm);\n    }\n\n    if (parameters === undefined) {\n      parameters = KeyParameters.deserializeJson(DEFAULT_ALGORITHM.parameters);\n    }\n\n    this.algorithm = algorithm;\n    this.parameters = parameters;\n  }\n  /**\r\n   * Computes hash of message using hashing function of signature schema.\r\n   *\r\n   * @param msg Hex encoded input data\r\n   * @param scheme Signing schema to use\r\n   */\n\n\n  _createClass(Key, [{\n    key: \"computeHash\",\n    value: function computeHash(msg, scheme) {\n      switch (scheme) {\n        case SignatureScheme.ECDSAwithSHA224:\n          return cryptoJS.SHA224(cryptoJS.enc.Hex.parse(msg)).toString();\n\n        case SignatureScheme.ECDSAwithSHA256:\n          return cryptoJS.SHA256(cryptoJS.enc.Hex.parse(msg)).toString();\n\n        case SignatureScheme.ECDSAwithSHA384:\n          return cryptoJS.SHA384(cryptoJS.enc.Hex.parse(msg)).toString();\n\n        case SignatureScheme.ECDSAwithSHA512:\n        case SignatureScheme.EDDSAwithSHA512:\n          return cryptoJS.SHA512(cryptoJS.enc.Hex.parse(msg)).toString();\n\n        case SignatureScheme.ECDSAwithSHA3_224:\n          return sha3_224(hexstring2ab(msg));\n\n        case SignatureScheme.ECDSAwithSHA3_256:\n          return sha3_256(hexstring2ab(msg));\n\n        case SignatureScheme.ECDSAwithSHA3_384:\n          return sha3_384(hexstring2ab(msg));\n\n        case SignatureScheme.ECDSAwithSHA3_512:\n          return sha3_512(hexstring2ab(msg));\n\n        case SignatureScheme.ECDSAwithRIPEMD160:\n          return cryptoJS.RIPEMD160(cryptoJS.enc.Hex.parse(msg)).toString();\n        //case SignatureScheme.SM2withSM3:\n        //return (new sm3()).sum(hexstring2ab(msg), 'hex');\n\n        default:\n          throw new Error('Unsupported hash algorithm.');\n      }\n    }\n    /**\r\n     * Tests if signing schema is compatible with key type.\r\n     *\r\n     * @param schema Signing schema to use\r\n     */\n\n  }, {\n    key: \"isSchemaSupported\",\n    value: function isSchemaSupported(schema) {\n      switch (schema) {\n        case SignatureScheme.ECDSAwithSHA224:\n        case SignatureScheme.ECDSAwithSHA256:\n        case SignatureScheme.ECDSAwithSHA384:\n        case SignatureScheme.ECDSAwithSHA512:\n        case SignatureScheme.ECDSAwithSHA3_224:\n        case SignatureScheme.ECDSAwithSHA3_256:\n        case SignatureScheme.ECDSAwithSHA3_384:\n        case SignatureScheme.ECDSAwithSHA3_512:\n        case SignatureScheme.ECDSAwithRIPEMD160:\n          return this.algorithm === KeyType.ECDSA;\n\n        case SignatureScheme.EDDSAwithSHA512:\n          return this.algorithm === KeyType.EDDSA;\n        //case SignatureScheme.SM2withSM3:\n        //return this.algorithm === KeyType.SM2;\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\r\n     * Gets JSON representation of the Key (Public/Private).\r\n     */\n\n  }, {\n    key: \"serializeJson\",\n    value: function serializeJson() {\n      return {\n        algorithm: this.algorithm.label,\n        parameters: this.parameters.serializeJson(),\n        key: this.key\n      };\n    }\n  }]);\n\n  return Key;\n}();",{"version":3,"sources":["C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\key.ts"],"names":[],"mappings":"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","sourcesContent":["import * as cryptoJS from 'crypto-js';\r\nimport { sha3_224, sha3_256, sha3_384, sha3_512 } from 'js-sha3';\r\nimport { hexstring2ab } from \"../common/functionsUtils\";\r\nimport { KeyType, KeyParameters, JsonKeyParameters } from \"./cryptoParams\";\r\nimport { SignatureScheme } from \"./cryptoParams\";\r\nimport { DEFAULT_ALGORITHM } from \"../common/consts\"\r\n\r\n/**\r\n * Common representation of private or public key\r\n */\r\nexport class Key {\r\n    key: string;\r\n    algorithm: KeyType;\r\n    parameters: KeyParameters;\r\n\r\n    /**\r\n     * Creates Key.\r\n     *\r\n     * If no algorithm or parameters are specified, default values will be used.\r\n     *\r\n     * @param key Hex encoded key value\r\n     * @param algorithm Key type\r\n     * @param parameters Parameters of the key type\r\n     */\r\n    constructor(key: string, algorithm?: KeyType, parameters?: KeyParameters) {\r\n        this.key = key;\r\n\r\n        if (algorithm === undefined) {\r\n            algorithm = KeyType.fromLabel(DEFAULT_ALGORITHM.algorithm);\r\n        }\r\n\r\n        if (parameters === undefined) {\r\n            parameters = KeyParameters.deserializeJson(DEFAULT_ALGORITHM.parameters);\r\n        }\r\n\r\n        this.algorithm = algorithm;\r\n        this.parameters = parameters;\r\n    }\r\n\r\n    /**\r\n     * Computes hash of message using hashing function of signature schema.\r\n     *\r\n     * @param msg Hex encoded input data\r\n     * @param scheme Signing schema to use\r\n     */\r\n    computeHash(msg: string, scheme: SignatureScheme): string {\r\n        switch (scheme) {\r\n            case SignatureScheme.ECDSAwithSHA224:\r\n                return cryptoJS.SHA224(cryptoJS.enc.Hex.parse(msg)).toString();\r\n            case SignatureScheme.ECDSAwithSHA256:\r\n                return cryptoJS.SHA256(cryptoJS.enc.Hex.parse(msg)).toString();\r\n            case SignatureScheme.ECDSAwithSHA384:\r\n                return cryptoJS.SHA384(cryptoJS.enc.Hex.parse(msg)).toString();\r\n            case SignatureScheme.ECDSAwithSHA512:\r\n            case SignatureScheme.EDDSAwithSHA512:\r\n                return cryptoJS.SHA512(cryptoJS.enc.Hex.parse(msg)).toString();\r\n            case SignatureScheme.ECDSAwithSHA3_224:\r\n                return sha3_224(hexstring2ab(msg));\r\n            case SignatureScheme.ECDSAwithSHA3_256:\r\n                return sha3_256(hexstring2ab(msg));\r\n            case SignatureScheme.ECDSAwithSHA3_384:\r\n                return sha3_384(hexstring2ab(msg));\r\n            case SignatureScheme.ECDSAwithSHA3_512:\r\n                return sha3_512(hexstring2ab(msg));\r\n            case SignatureScheme.ECDSAwithRIPEMD160:\r\n                return cryptoJS.RIPEMD160(cryptoJS.enc.Hex.parse(msg)).toString();\r\n            //case SignatureScheme.SM2withSM3:\r\n                //return (new sm3()).sum(hexstring2ab(msg), 'hex');\r\n            default:\r\n                throw new Error('Unsupported hash algorithm.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if signing schema is compatible with key type.\r\n     *\r\n     * @param schema Signing schema to use\r\n     */\r\n    isSchemaSupported(schema: SignatureScheme): boolean {\r\n        switch (schema) {\r\n            case SignatureScheme.ECDSAwithSHA224:\r\n            case SignatureScheme.ECDSAwithSHA256:\r\n            case SignatureScheme.ECDSAwithSHA384:\r\n            case SignatureScheme.ECDSAwithSHA512:\r\n            case SignatureScheme.ECDSAwithSHA3_224:\r\n            case SignatureScheme.ECDSAwithSHA3_256:\r\n            case SignatureScheme.ECDSAwithSHA3_384:\r\n            case SignatureScheme.ECDSAwithSHA3_512:\r\n            case SignatureScheme.ECDSAwithRIPEMD160:\r\n                return this.algorithm === KeyType.ECDSA;\r\n            case SignatureScheme.EDDSAwithSHA512:\r\n                return this.algorithm === KeyType.EDDSA;\r\n            //case SignatureScheme.SM2withSM3:\r\n                //return this.algorithm === KeyType.SM2;\r\n            default:\r\n                throw new Error('Unsupported signature schema.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets JSON representation of the Key (Public/Private).\r\n     */\r\n    serializeJson(): JsonKey {\r\n        return {\r\n            algorithm: this.algorithm.label,\r\n            parameters: this.parameters.serializeJson(),\r\n            key: this.key\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Json representation of the Key.\r\n */\r\nexport interface JsonKey {\r\n    algorithm: string;\r\n    parameters: JsonKeyParameters;\r\n    key: string | null;\r\n    external?: any | null;\r\n}\r\n"],"sourceRoot":""}]}