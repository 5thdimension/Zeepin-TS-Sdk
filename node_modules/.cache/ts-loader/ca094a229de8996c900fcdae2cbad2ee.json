{"remainingRequest":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js??ref--13-2!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\common\\functionsUtils.ts","dependencies":[{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\common\\functionsUtils.ts","mtime":1601302458182},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport _getIterator from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/get-iterator\";\nimport \"core-js/modules/es6.string.repeat\";\nimport _Number$isSafeInteger from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/number/is-safe-integer\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport _parseInt from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/parse-int\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport * as cryptoJS from 'crypto-js';\nimport { ERROR_CODE } from \"./error\";\n/**\r\n * Creates random bytes.\r\n *\r\n * @param data Hex encoded data\r\n */\n\nexport function randomBytes(len) {\n  return cryptoJS.lib.WordArray.random(len).toString();\n  ;\n}\n/**\r\n * Computes sha-256 hash from hex encoded data.\r\n *\r\n * @param data Hex encoded data\r\n */\n\nexport function sha256(data) {\n  var hex = cryptoJS.enc.Hex.parse(data);\n  var sha = cryptoJS.SHA256(hex).toString();\n  return sha;\n}\n/**\r\n * Turn hex string into array buffer\r\n * @param str hex string\r\n */\n\nexport function hexstring2ab(str) {\n  var result = [];\n\n  while (str.length >= 2) {\n    result.push(_parseInt(str.substring(0, 2), 16));\n    str = str.substring(2, str.length);\n  }\n\n  return result;\n}\n/**\r\n * Turn array buffer into hex string\r\n * @param arr Array like value\r\n */\n\nexport function ab2hexstring(arr) {\n  var result = '';\n  var uint8Arr = new Uint8Array(arr);\n\n  for (var i = 0; i < uint8Arr.byteLength; i++) {\n    var str = uint8Arr[i].toString(16);\n    str = str.length === 0 ? '00' : str.length === 1 ? '0' + str : str;\n    result += str;\n  }\n\n  return result;\n}\n/**\r\n * Converts a number to a big endian hexstring of a suitable size, optionally little endian\r\n * @param {number} num\r\n * @param {number} size - The required size in bytes, eg 1 for Uint8, 2 for Uint16. Defaults to 1.\r\n * @param {boolean} littleEndian - Encode the hex in little endian form\r\n * @return {string}\r\n */\n\nexport var num2hexstring = function num2hexstring(num) {\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var littleEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (num < 0) {\n    throw new RangeError('num must be >=0');\n  }\n\n  if (size % 1 !== 0) {\n    throw new Error('size must be a whole integer');\n  }\n\n  if (!_Number$isSafeInteger(num)) {\n    throw new RangeError(\"num (\".concat(num, \") must be a safe integer\"));\n  }\n\n  size = size * 2;\n  var hexstring = num.toString(16);\n  hexstring = hexstring.length % size === 0 ? hexstring : ('0'.repeat(size) + hexstring).substring(hexstring.length);\n\n  if (littleEndian) {\n    hexstring = reverseHex(hexstring);\n  }\n\n  return hexstring;\n};\n/**\r\n * Turn normal string into ArrayBuffer\r\n * @param str Normal string\r\n */\n\nexport function str2ab(str) {\n  var buf = new ArrayBuffer(str.length); // 每个字符占用1个字节\n\n  var bufView = new Uint8Array(buf);\n\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n}\n/**\r\n * Turn ArrayBuffer or array-like oject into normal string\r\n * @param buf\r\n */\n\nexport function ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf));\n}\n/**\r\n * Turn normal string into hex string\r\n * @param str Normal string\r\n */\n\nexport function str2hexstr(str) {\n  return ab2hexstring(str2ab(str));\n}\n/**\r\n * Turn hex string into normal string\r\n * @param str Hex string\r\n */\n\nexport function hexstr2str(str) {\n  return ab2str(hexstring2ab(str));\n}\n/**\r\n * return the (length of bytes) + bytes\r\n * @param hex Hex string\r\n */\n\nexport function hex2VarBytes(hex) {\n  var result = '';\n  result += num2VarInt(hex.length / 2);\n  result += hex;\n  return result;\n}\n/**\r\n * Converts a number to a hex\r\n * @param {number} num - The number\r\n * @returns {string} hexstring of the variable Int.\r\n */\n\nexport var num2VarInt = function num2VarInt(num) {\n  if (num < 0xfd) {\n    return num2hexstring(num);\n  } else if (num <= 0xffff) {\n    // uint16\n    return 'fd' + num2hexstring(num, 2, true);\n  } else if (num <= 0xffffffff) {\n    // uint32\n    return 'fe' + num2hexstring(num, 4, true);\n  } else {\n    // uint64\n    return 'ff' + num2hexstring(num, 8, true);\n  }\n}; // @ts-ignore\n\nexport function bigIntToBytes(value) {\n  var data = value.toBytesLE();\n  var negData = value.neg().toBytesLE();\n  var stop;\n\n  if (value.isNegative()) {\n    stop = 255;\n  } else {\n    stop = 0;\n  }\n\n  var b = stop;\n  var pos = 0;\n\n  for (var i = data.length - 1; i >= 0; i--) {\n    if (data[i] !== stop) {\n      b = value.isNegative() ? negData[i] : data[i];\n      pos = i + 1;\n      break;\n    }\n  }\n\n  data = data.slice(0, pos);\n\n  if (b >> 7 === 1) {\n    data.push(value.isNegative() ? 255 : 0);\n  }\n\n  return new Buffer(data).toString('hex');\n}\n/**\r\n * Reverses a hex string, 2 chars as 1 byte\r\n * @example\r\n * reverseHex('abcdef') = 'efcdab'\r\n * @param {string} hex - HEX string\r\n * @return {string} reversed hex string.\r\n */\n\nexport var reverseHex = function reverseHex(hex) {\n  if (hex.length % 2 !== 0) {\n    throw new Error(\"Incorrect Length: \".concat(hex));\n  }\n\n  var out = '';\n\n  for (var i = hex.length - 2; i >= 0; i -= 2) {\n    out += hex.substr(i, 2);\n  }\n\n  return out;\n};\n/**\r\n * Computes ripemd-160 hash of sha-256 hash from hex encoded data.\r\n *\r\n * @param data Hex encoded data\r\n */\n\nexport function hash160(SignatureScript) {\n  return ripemd160(sha256(SignatureScript));\n}\n/**\r\n * Computes ripemd-160 hash from hex encoded data.\r\n *\r\n * @param data Hex encoded data\r\n */\n\nexport function ripemd160(data) {\n  var hex = cryptoJS.enc.Hex.parse(data);\n  var ripemd = cryptoJS.RIPEMD160(hex).toString();\n  return ripemd;\n}\nexport function isHexString(str) {\n  var regexp = /^[0-9a-fA-F]+$/;\n  return regexp.test(str) && str.length % 2 === 0;\n}\nexport function isBase64(str) {\n  return Buffer.from(str, 'base64').toString('base64') === str;\n}\n/**\r\n * Concat params as the query part in rest\r\n * @param params\r\n */\n\nexport function concatParams(params) {\n  var result = '';\n\n  if (params.size === 0) {\n    return '';\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(params.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      var value = params.get(key);\n\n      if (value) {\n        value = encodeURIComponent(value);\n      }\n\n      result += \"&\".concat(key, \"=\").concat(value);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return '?' + result.substr(1);\n}\nexport function keystoreCheck(keystore) {\n  if (!keystore.hasOwnProperty('accounts')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  } // @ts-ignore\n\n\n  var account = keystore.accounts[0];\n\n  if (!account.hasOwnProperty('address')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  }\n\n  if (!account.hasOwnProperty('key')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  }\n\n  if (!account.hasOwnProperty('salt')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  }\n}",{"version":3,"sources":["C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\common\\functionsUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Long from 'long';\r\nimport * as cryptoJS from 'crypto-js'\r\nimport { ERROR_CODE } from \"./error\";\r\n\r\n/**\r\n * Creates random bytes.\r\n *\r\n * @param data Hex encoded data\r\n */\r\nexport function randomBytes (len: number) {\r\n    return cryptoJS.lib.WordArray.random(len).toString();;\r\n}\r\n\r\n/**\r\n * Computes sha-256 hash from hex encoded data.\r\n *\r\n * @param data Hex encoded data\r\n */\r\nexport function sha256 (data: string) {\r\n    const hex = cryptoJS.enc.Hex.parse(data);\r\n    const sha = cryptoJS.SHA256(hex).toString();\r\n    return sha;\r\n}\r\n\r\n/**\r\n * Turn hex string into array buffer\r\n * @param str hex string\r\n */\r\nexport function hexstring2ab(str: string): number[] {\r\n    const result:number[] = [];\r\n    while (str.length >= 2) {\r\n        result.push(parseInt(str.substring(0, 2), 16));\r\n        str = str.substring(2, str.length);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Turn array buffer into hex string\r\n * @param arr Array like value\r\n */\r\nexport function ab2hexstring(arr: any): string {\r\n    let result: string = '';\r\n    const uint8Arr: Uint8Array = new Uint8Array(arr);\r\n    for (let i = 0; i < uint8Arr.byteLength; i++) {\r\n        let str = uint8Arr[i].toString(16);\r\n        str = str.length === 0\r\n            ? '00'\r\n            : str.length === 1\r\n                ? '0' + str\r\n                : str;\r\n        result += str;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Converts a number to a big endian hexstring of a suitable size, optionally little endian\r\n * @param {number} num\r\n * @param {number} size - The required size in bytes, eg 1 for Uint8, 2 for Uint16. Defaults to 1.\r\n * @param {boolean} littleEndian - Encode the hex in little endian form\r\n * @return {string}\r\n */\r\nexport const num2hexstring = (num: number, size = 1, littleEndian = false) => {\r\n    if (num < 0) {\r\n        throw new RangeError('num must be >=0');\r\n    }\r\n    if (size % 1 !== 0) {\r\n        throw new Error('size must be a whole integer');\r\n    }\r\n    if (!Number.isSafeInteger(num)) {\r\n        throw new RangeError(`num (${num}) must be a safe integer`);\r\n    }\r\n\r\n    size = size * 2;\r\n    let hexstring = num.toString(16);\r\n    hexstring = hexstring.length % size === 0 ? hexstring : ('0'.repeat(size) + hexstring).substring(hexstring.length);\r\n    if (littleEndian) {\r\n        hexstring = reverseHex(hexstring);\r\n    }\r\n    return hexstring;\r\n};\r\n\r\n/**\r\n * Turn normal string into ArrayBuffer\r\n * @param str Normal string\r\n */\r\nexport function str2ab(str: string) {\r\n    const buf = new ArrayBuffer(str.length); // 每个字符占用1个字节\r\n    const bufView = new Uint8Array(buf);\r\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\r\n        bufView[i] = str.charCodeAt(i);\r\n    }\r\n    return buf;\r\n}\r\n\r\n/**\r\n * Turn ArrayBuffer or array-like oject into normal string\r\n * @param buf\r\n */\r\nexport function ab2str(buf: ArrayBuffer | number[]): string {\r\n    return String.fromCharCode.apply(null, new Uint8Array(buf));\r\n}\r\n\r\n/**\r\n * Turn normal string into hex string\r\n * @param str Normal string\r\n */\r\nexport function str2hexstr(str: string) {\r\n    return ab2hexstring(str2ab(str));\r\n}\r\n\r\n/**\r\n * Turn hex string into normal string\r\n * @param str Hex string\r\n */\r\nexport function hexstr2str(str: string) {\r\n    return ab2str(hexstring2ab(str));\r\n}\r\n\r\n/**\r\n * return the (length of bytes) + bytes\r\n * @param hex Hex string\r\n */\r\nexport function hex2VarBytes(hex: string) {\r\n    let result = '';\r\n    result += num2VarInt(hex.length / 2);\r\n    result += hex;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Converts a number to a hex\r\n * @param {number} num - The number\r\n * @returns {string} hexstring of the variable Int.\r\n */\r\nexport const num2VarInt = (num: number) => {\r\n    if (num < 0xfd) {\r\n        return num2hexstring(num);\r\n    } else if (num <= 0xffff) {\r\n        // uint16\r\n        return 'fd' + num2hexstring(num, 2, true);\r\n    } else if (num <= 0xffffffff) {\r\n        // uint32\r\n        return 'fe' + num2hexstring(num, 4, true);\r\n    } else {\r\n        // uint64\r\n        return 'ff' + num2hexstring(num, 8, true);\r\n    }\r\n};\r\n\r\n\r\n\r\n// @ts-ignore\r\nexport function bigIntToBytes(value: Long) {\r\n    let data = value.toBytesLE();\r\n    const negData = value.neg().toBytesLE();\r\n    let stop;\r\n    if (value.isNegative()) {\r\n        stop = 255;\r\n    } else {\r\n        stop = 0;\r\n    }\r\n    let b = stop;\r\n    let pos = 0;\r\n    for (let i = data.length - 1; i >= 0; i--) {\r\n        if (data[i] !== stop) {\r\n            b = value.isNegative() ? negData[i] : data[i];\r\n            pos = i + 1;\r\n            break;\r\n        }\r\n    }\r\n    data = data.slice(0, pos);\r\n\r\n    if (b >> 7 === 1) {\r\n        data.push(value.isNegative() ? 255 : 0);\r\n    }\r\n    return new Buffer(data).toString('hex');\r\n}\r\n\r\n/**\r\n * Reverses a hex string, 2 chars as 1 byte\r\n * @example\r\n * reverseHex('abcdef') = 'efcdab'\r\n * @param {string} hex - HEX string\r\n * @return {string} reversed hex string.\r\n */\r\nexport const reverseHex = (hex: string) => {\r\n    if (hex.length % 2 !== 0) {\r\n        throw new Error(`Incorrect Length: ${hex}`);\r\n    }\r\n    let out = '';\r\n    for (let i = hex.length - 2; i >= 0; i -= 2) {\r\n        out += hex.substr(i, 2);\r\n    }\r\n    return out;\r\n};\r\n\r\n\r\n/**\r\n * Computes ripemd-160 hash of sha-256 hash from hex encoded data.\r\n *\r\n * @param data Hex encoded data\r\n */\r\nexport function hash160(SignatureScript: string): string {\r\n    return ripemd160(sha256(SignatureScript));\r\n}\r\n\r\n/**\r\n * Computes ripemd-160 hash from hex encoded data.\r\n *\r\n * @param data Hex encoded data\r\n */\r\nexport function ripemd160(data: string) {\r\n    const hex = cryptoJS.enc.Hex.parse(data);\r\n    const ripemd = cryptoJS.RIPEMD160(hex).toString();\r\n    return ripemd;\r\n}\r\n\r\nexport function isHexString(str: string): boolean {\r\n    const regexp = /^[0-9a-fA-F]+$/;\r\n    return regexp.test(str) && (str.length % 2 === 0);\r\n}\r\n\r\nexport function isBase64(str: string): boolean {\r\n    return Buffer.from(str, 'base64').toString('base64') === str;\r\n}\r\n\r\n/**\r\n * Concat params as the query part in rest\r\n * @param params\r\n */\r\nexport function concatParams(params: Map<string, string>) {\r\n    let result = '';\r\n    if (params.size === 0) {\r\n        return '';\r\n    }\r\n\r\n    for (const key of params.keys()) {\r\n        let value = params.get(key);\r\n        if (value) {\r\n            value = encodeURIComponent(value);\r\n        }\r\n        result += `&${key}=${value}`;\r\n    }\r\n\r\n    return '?' + result.substr(1);\r\n}\r\n\r\nexport function keystoreCheck(keystore: object) {\r\n    if(!keystore.hasOwnProperty('accounts')) {\r\n        throw ERROR_CODE.Keystore_ERROR;\r\n    }\r\n\r\n\t// @ts-ignore\r\n    let account = keystore.accounts[0];\r\n\r\n    if(!account.hasOwnProperty('address')) {\r\n        throw ERROR_CODE.Keystore_ERROR;\r\n    }\r\n\r\n    if(!account.hasOwnProperty('key')) {\r\n        throw ERROR_CODE.Keystore_ERROR;\r\n    }\r\n\r\n    if(!account.hasOwnProperty('salt')) {\r\n        throw ERROR_CODE.Keystore_ERROR;\r\n    }\r\n}\r\n"],"sourceRoot":""}]}