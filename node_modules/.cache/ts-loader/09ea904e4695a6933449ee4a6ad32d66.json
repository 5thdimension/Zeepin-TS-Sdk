{"remainingRequest":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js??ref--13-2!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\privateKey.ts","dependencies":[{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\privateKey.ts","mtime":1601302458191},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _classCallCheck from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/inherits\";\nimport * as elliptic from 'elliptic';\nimport { randomBytes, isBase64 } from \"../common/functionsUtils\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { Key } from \"./key\";\nimport { KeyType, SignatureScheme } from \"./cryptoParams\";\nimport { PublicKey } from \"./publicKey\";\nimport { Address } from \"../wallet/address\";\nimport { encryptWithGcm, decryptWithGcm } from \"./scrypt\";\nimport { Signature } from \"./signature\";\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\nexport var PrivateKey =\n/*#__PURE__*/\nfunction (_Key) {\n  _inherits(PrivateKey, _Key);\n\n  function PrivateKey() {\n    _classCallCheck(this, PrivateKey);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PrivateKey).apply(this, arguments));\n  }\n\n  _createClass(PrivateKey, [{\n    key: \"getPublicKey\",\n\n    /**\r\n     * Derives Public key out of Private key.\r\n     */\n    value: function getPublicKey() {\n      switch (this.algorithm) {\n        case KeyType.ECDSA:\n          return this.getEcDSAPublicKey();\n\n        case KeyType.EDDSA:\n          return this.getEdDSAPublicKey();\n        // case KeyType.SM2:\n        //     return this.getSM2PublicKey();\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\r\n     * Derives Public key out of Private key using EcDSA algorithm.\r\n     */\n\n  }, {\n    key: \"getEcDSAPublicKey\",\n    value: function getEcDSAPublicKey() {\n      var ec = new elliptic.ec(this.parameters.curve.preset);\n      var keyPair = ec.keyFromPrivate(this.key, 'hex');\n      var pk = keyPair.getPublic(true, 'hex');\n      return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n    /**\r\n     * Derives Public key out of Private key using EdDSA algorithm.\r\n     */\n\n  }, {\n    key: \"getEdDSAPublicKey\",\n    value: function getEdDSAPublicKey() {\n      var eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n      var keyPair = eddsa.keyFromSecret(this.key, 'hex');\n      var pk = keyPair.getPublic(true, 'hex');\n      return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n    /**\r\n     * Decrypts encrypted private key with supplied password.\r\n     *\r\n     * @param keyphrase Password to decrypt with\r\n     * @param address For aad in decryption\r\n     * @param 16 secure random bytes\r\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(keyphrase, address, salt, n) {\n      if (salt.length === 24 && isBase64(salt)) {\n        salt = Buffer.from(salt, 'base64').toString('hex');\n      }\n\n      var params;\n\n      if (!n) {\n        params = DEFAULT_SCRYPT;\n      } else {\n        params = {\n          cost: n,\n          blockSize: 8,\n          parallel: 8,\n          size: 64\n        };\n      }\n\n      var decrypted = decryptWithGcm(this.key, address, salt, keyphrase, params);\n      var decryptedKey = new PrivateKey(decrypted, this.algorithm, this.parameters);\n      var pk = decryptedKey.getPublicKey();\n      var addrTmp = Address.fromPubKey(pk);\n\n      if (addrTmp.toBase58() !== address.toBase58()) {\n        throw ERROR_CODE.Decrypto_ERROR;\n      }\n\n      return decryptedKey;\n    }\n    /**\r\n     * Encrypts private key with supplied password.\r\n     *\r\n     * @param keyphrase Password to encrypt with\r\n     * @param address For aad in encryption\r\n     * @param salt 16 secure random bytes\r\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(keyphrase, address, salt, n) {\n      var publicKey = this.getPublicKey();\n      var addr = Address.fromPubKey(publicKey).toBase58();\n\n      if (addr !== address.toBase58()) {\n        throw ERROR_CODE.INVALID_ADDR;\n      }\n\n      var params;\n\n      if (!n) {\n        params = DEFAULT_SCRYPT;\n      } else {\n        params = {\n          cost: n,\n          blockSize: 8,\n          parallel: 8,\n          size: 64\n        };\n      }\n\n      var encrypted = encryptWithGcm(this.key, address, salt, keyphrase, params);\n      return new PrivateKey(encrypted, this.algorithm, this.parameters);\n    }\n    /**\r\n     * Signs the data with supplied private key using signature schema.\r\n     *\r\n     * If the signature schema is not provided, the default schema for this key type is used.\r\n     *\r\n     * This method is not suitable, if external keys (Ledger, TPM, ...) support is required.\r\n     *\r\n     * @param msg Hex encoded input data or Signable object\r\n     * @param schema Signing schema to use\r\n     * @param publicKeyId Id of public key\r\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(msg, schema, publicKeyId) {\n      if (schema === undefined) {\n        schema = this.algorithm.defaultSchema;\n      }\n\n      if (!this.isSchemaSupported(schema)) {\n        throw new Error('Signature schema does not match key type.');\n      } // retrieves content to sign if not provided directly\n\n\n      if (typeof msg !== 'string') {\n        msg = msg.getSignContent();\n      }\n\n      var hash;\n\n      if (schema === SignatureScheme.SM2withSM3) {\n        // library sm.js (SM2withSM3) has implemented hashing as part of signing, therefore it is skipped\n        hash = msg;\n      } else {\n        hash = this.computeHash(msg, schema);\n      }\n\n      var signed = this.computeSignature(hash, schema);\n      return new Signature(schema, signed, publicKeyId);\n    }\n    /**\r\n     * Computes signature of message hash using specified signature schema.\r\n     *\r\n     * @param hash Message hash\r\n     * @param schema Signature schema to use\r\n     */\n\n  }, {\n    key: \"computeSignature\",\n    value: function computeSignature(hash, schema) {\n      switch (schema) {\n        case SignatureScheme.ECDSAwithSHA224:\n        case SignatureScheme.ECDSAwithSHA256:\n        case SignatureScheme.ECDSAwithSHA384:\n        case SignatureScheme.ECDSAwithSHA512:\n        case SignatureScheme.ECDSAwithSHA3_224:\n        case SignatureScheme.ECDSAwithSHA3_256:\n        case SignatureScheme.ECDSAwithSHA3_384:\n        case SignatureScheme.ECDSAwithSHA3_512:\n        case SignatureScheme.ECDSAwithRIPEMD160:\n          return this.computeEcDSASignature(hash);\n\n        case SignatureScheme.EDDSAwithSHA512:\n          return this.computeEdDSASignature(hash);\n        // case SignatureScheme.SM2withSM3:\n        //     return this.computeSM2Signature(hash);\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\r\n     * Computes EcDSA signature of message hash. Curve name is derrived from private key.\r\n     *\r\n     * @param hash Message hash\r\n     */\n\n  }, {\n    key: \"computeEcDSASignature\",\n    value: function computeEcDSASignature(hash) {\n      var ec = new elliptic.ec(this.parameters.curve.preset);\n      var signed = ec.sign(hash, this.key, {\n        canonical: true\n      });\n      return Buffer.concat([signed.r.toArrayLike(Buffer, 'be', 32), signed.s.toArrayLike(Buffer, 'be', 32)]).toString('hex');\n    }\n    /**\r\n     * Computes EdDSA signature of message hash. Curve name is derrived from private key.\r\n     *\r\n     * @param hash Message hash\r\n     */\n\n  }, {\n    key: \"computeEdDSASignature\",\n    value: function computeEdDSASignature(hash) {\n      var eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n      var signed = eddsa.sign(hash, this.key, null);\n      return Buffer.concat([signed.R.toArrayLike(Buffer, 'be', 32), signed.S.toArrayLike(Buffer, 'be', 32)]).toString('hex');\n    }\n  }], [{\n    key: \"random\",\n\n    /**\r\n     * Generates random Private key using supplied Key type and parameters.\r\n     *\r\n     * If no Key type or parameters is supplied, default SDK key type with default parameters will be used.\r\n     */\n    value: function random(keyType, parameters) {\n      return new PrivateKey(randomBytes(32), keyType, parameters);\n    }\n  }]);\n\n  return PrivateKey;\n}(Key);",{"version":3,"sources":["C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\privateKey.ts"],"names":[],"mappings":";;;;;;;AAAA,OAAO,KAAK,QAAZ,MAA0B,UAA1B;AACA,SAAS,WAAT,EAAsB,QAAtB,QAAsC,0BAAtC;AACA,SAAS,UAAT,QAA2B,iBAA3B;AACA,SAAS,GAAT,QAAoB,OAApB;AACA,SAAS,OAAT,EAAiC,eAAjC,QAAwD,gBAAxD;AACA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,OAAT,QAAwB,mBAAxB;AACA,SAAS,cAAT,EAAyB,cAAzB,QAA6D,UAA7D;AACA,SAAS,SAAT,QAA0B,aAA1B;AAEA,SAAS,cAAT,QAA+B,kBAA/B;AAEA,WAAa,UAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAUI;;;AAVJ,mCAagB;AACR,cAAQ,KAAK,SAAb;AACI,aAAK,OAAO,CAAC,KAAb;AACI,iBAAO,KAAK,iBAAL,EAAP;;AACJ,aAAK,OAAO,CAAC,KAAb;AACI,iBAAO,KAAK,iBAAL,EAAP;AACJ;AACA;;AACA;AACI,gBAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AARR;AAUH;AAED;;;;AA1BJ;AAAA;AAAA,wCA6BqB;AACb,UAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,EAAb,CAAgB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAtC,CAAX;AACA,UAAM,OAAO,GAAG,EAAE,CAAC,cAAH,CAAkB,KAAK,GAAvB,EAA4B,KAA5B,CAAhB;AACA,UAAM,EAAE,GAAG,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,KAAxB,CAAX;AAEA,aAAO,IAAI,SAAJ,CAAc,EAAd,EAAkB,KAAK,SAAvB,EAAkC,KAAK,UAAvC,CAAP;AACH;AAED;;;;AArCJ;AAAA;AAAA,wCAwCqB;AACb,UAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,KAAb,CAAmB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAzC,CAAd;AACA,UAAM,OAAO,GAAG,KAAK,CAAC,aAAN,CAAoB,KAAK,GAAzB,EAA8B,KAA9B,CAAhB;AACA,UAAM,EAAE,GAAG,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,KAAxB,CAAX;AAEA,aAAO,IAAI,SAAJ,CAAc,EAAd,EAAkB,KAAK,SAAvB,EAAkC,KAAK,UAAvC,CAAP;AACH;AAED;;;;;;;;AAhDJ;AAAA;AAAA,4BAuDY,SAvDZ,EAuD+B,OAvD/B,EAuDiD,IAvDjD,EAuD+D,CAvD/D,EAuDyE;AACjE,UAAI,IAAI,CAAC,MAAL,KAAgB,EAAhB,IAAsB,QAAQ,CAAC,IAAD,CAAlC,EAA0C;AACtC,QAAA,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,EAA4B,QAA5B,CAAqC,KAArC,CAAP;AACH;;AACD,UAAI,MAAJ;;AACA,UAAI,CAAC,CAAL,EAAQ;AACJ,QAAA,MAAM,GAAG,cAAT;AACH,OAFD,MAEO;AACH,QAAA,MAAM,GAAG;AACL,UAAA,IAAI,EAAE,CADD;AAEL,UAAA,SAAS,EAAE,CAFN;AAGL,UAAA,QAAQ,EAAE,CAHL;AAIL,UAAA,IAAI,EAAE;AAJD,SAAT;AAMH;;AACD,UAAM,SAAS,GAAG,cAAc,CAAC,KAAK,GAAN,EAAW,OAAX,EAAoB,IAApB,EAA0B,SAA1B,EAAqC,MAArC,CAAhC;AACA,UAAM,YAAY,GAAG,IAAI,UAAJ,CAAe,SAAf,EAA0B,KAAK,SAA/B,EAA0C,KAAK,UAA/C,CAArB;AACA,UAAM,EAAE,GAAG,YAAY,CAAC,YAAb,EAAX;AACA,UAAM,OAAO,GAAG,OAAO,CAAC,UAAR,CAAmB,EAAnB,CAAhB;;AACA,UAAI,OAAO,CAAC,QAAR,OAAuB,OAAO,CAAC,QAAR,EAA3B,EAA+C;AAC3C,cAAM,UAAU,CAAC,cAAjB;AACH;;AACD,aAAO,YAAP;AACH;AAED;;;;;;;;AAhFJ;AAAA;AAAA,4BAuFY,SAvFZ,EAuF+B,OAvF/B,EAuFiD,IAvFjD,EAuF+D,CAvF/D,EAuFyE;AACjE,UAAM,SAAS,GAAG,KAAK,YAAL,EAAlB;AACA,UAAM,IAAI,GAAG,OAAO,CAAC,UAAR,CAAmB,SAAnB,EAA8B,QAA9B,EAAb;;AACA,UAAI,IAAI,KAAK,OAAO,CAAC,QAAR,EAAb,EAAiC;AAC7B,cAAM,UAAU,CAAC,YAAjB;AACH;;AACD,UAAI,MAAJ;;AACA,UAAI,CAAC,CAAL,EAAQ;AACJ,QAAA,MAAM,GAAG,cAAT;AACH,OAFD,MAEO;AACH,QAAA,MAAM,GAAG;AACL,UAAA,IAAI,EAAE,CADD;AAEL,UAAA,SAAS,EAAE,CAFN;AAGL,UAAA,QAAQ,EAAE,CAHL;AAIL,UAAA,IAAI,EAAE;AAJD,SAAT;AAMH;;AACD,UAAM,SAAS,GAAG,cAAc,CAAC,KAAK,GAAN,EAAW,OAAX,EAAoB,IAApB,EAA0B,SAA1B,EAAqC,MAArC,CAAhC;AACA,aAAO,IAAI,UAAJ,CAAe,SAAf,EAA0B,KAAK,SAA/B,EAA0C,KAAK,UAA/C,CAAP;AACH;AAED;;;;;;;;;;;;AA5GJ;AAAA;AAAA,yBAuHS,GAvHT,EAuHiC,MAvHjC,EAuH2D,WAvH3D,EAuH+E;AACvE,UAAI,MAAM,KAAK,SAAf,EAA0B;AACtB,QAAA,MAAM,GAAG,KAAK,SAAL,CAAe,aAAxB;AACH;;AAED,UAAI,CAAC,KAAK,iBAAL,CAAuB,MAAvB,CAAL,EAAqC;AACjC,cAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;AACH,OAPsE,CASvE;;;AACA,UAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AACzB,QAAA,GAAG,GAAG,GAAG,CAAC,cAAJ,EAAN;AACH;;AAED,UAAI,IAAJ;;AACA,UAAI,MAAM,KAAK,eAAe,CAAC,UAA/B,EAA2C;AACvC;AACA,QAAA,IAAI,GAAG,GAAP;AACH,OAHD,MAGO;AACH,QAAA,IAAI,GAAG,KAAK,WAAL,CAAiB,GAAjB,EAAsB,MAAtB,CAAP;AACH;;AAED,UAAM,MAAM,GAAG,KAAK,gBAAL,CAAsB,IAAtB,EAA4B,MAA5B,CAAf;AACA,aAAO,IAAI,SAAJ,CAAc,MAAd,EAAsB,MAAtB,EAA8B,WAA9B,CAAP;AACH;AAED;;;;;;;AAjJJ;AAAA;AAAA,qCAuJqB,IAvJrB,EAuJmC,MAvJnC,EAuJ0D;AAClD,cAAQ,MAAR;AACI,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,kBAArB;AACI,iBAAO,KAAK,qBAAL,CAA2B,IAA3B,CAAP;;AACJ,aAAK,eAAe,CAAC,eAArB;AACI,iBAAO,KAAK,qBAAL,CAA2B,IAA3B,CAAP;AACJ;AACA;;AACA;AACI,gBAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AAhBR;AAkBH;AAED;;;;;;AA5KJ;AAAA;AAAA,0CAiL0B,IAjL1B,EAiLsC;AAC9B,UAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,EAAb,CAAgB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAtC,CAAX;AACA,UAAM,MAAM,GAAG,EAAE,CAAC,IAAH,CAAQ,IAAR,EAAc,KAAK,GAAnB,EAAwB;AAAE,QAAA,SAAS,EAAE;AAAb,OAAxB,CAAf;AACA,aAAO,MAAM,CAAC,MAAP,CAAc,CACjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CADiB,EAEjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CAFiB,CAAd,EAGJ,QAHI,CAGK,KAHL,CAAP;AAIH;AAED;;;;;;AA1LJ;AAAA;AAAA,0CA+L0B,IA/L1B,EA+LsC;AAC9B,UAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,KAAb,CAAmB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAzC,CAAd;AACA,UAAM,MAAM,GAAG,KAAK,CAAC,IAAN,CAAW,IAAX,EAAiB,KAAK,GAAtB,EAA2B,IAA3B,CAAf;AACA,aAAO,MAAM,CAAC,MAAP,CAAc,CACjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CADiB,EAEjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CAFiB,CAAd,EAGJ,QAHI,CAGK,KAHL,CAAP;AAIH;AAtML;AAAA;;AACI;;;;;AADJ,2BAMkB,OANlB,EAMqC,UANrC,EAM+D;AACvD,aAAO,IAAI,UAAJ,CAAe,WAAW,CAAC,EAAD,CAA1B,EAAgC,OAAhC,EAAyC,UAAzC,CAAP;AACH;AARL;;AAAA;AAAA,EAAgC,GAAhC","sourcesContent":["import * as elliptic from 'elliptic';\r\nimport { randomBytes, isBase64 } from \"../common/functionsUtils\";\r\nimport { ERROR_CODE } from \"../common/error\";\r\nimport { Key } from \"./key\"\r\nimport { KeyType, KeyParameters, SignatureScheme } from \"./cryptoParams\";\r\nimport { PublicKey } from \"./publicKey\";\r\nimport { Address } from \"../wallet/address\";\r\nimport { encryptWithGcm, decryptWithGcm, ScryptParams } from \"./scrypt\";\r\nimport { Signature } from \"./signature\";\r\nimport { Signable} from \"./signable\";\r\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\r\n\r\nexport class PrivateKey extends Key {\r\n    /**\r\n     * Generates random Private key using supplied Key type and parameters.\r\n     *\r\n     * If no Key type or parameters is supplied, default SDK key type with default parameters will be used.\r\n     */\r\n    static random(keyType?: KeyType, parameters?: KeyParameters): PrivateKey {\r\n        return new PrivateKey(randomBytes(32), keyType, parameters);\r\n    }\r\n\r\n    /**\r\n     * Derives Public key out of Private key.\r\n     */\r\n    getPublicKey(): PublicKey {\r\n        switch (this.algorithm) {\r\n            case KeyType.ECDSA:\r\n                return this.getEcDSAPublicKey();\r\n            case KeyType.EDDSA:\r\n                return this.getEdDSAPublicKey();\r\n            // case KeyType.SM2:\r\n            //     return this.getSM2PublicKey();\r\n            default:\r\n                throw new Error('Unsupported signature schema.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Derives Public key out of Private key using EcDSA algorithm.\r\n     */\r\n    getEcDSAPublicKey(): PublicKey {\r\n        const ec = new elliptic.ec(this.parameters.curve.preset);\r\n        const keyPair = ec.keyFromPrivate(this.key, 'hex');\r\n        const pk = keyPair.getPublic(true, 'hex');\r\n\r\n        return new PublicKey(pk, this.algorithm, this.parameters);\r\n    }\r\n\r\n    /**\r\n     * Derives Public key out of Private key using EdDSA algorithm.\r\n     */\r\n    getEdDSAPublicKey(): PublicKey {\r\n        const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\r\n        const keyPair = eddsa.keyFromSecret(this.key, 'hex');\r\n        const pk = keyPair.getPublic(true, 'hex');\r\n\r\n        return new PublicKey(pk, this.algorithm, this.parameters);\r\n    }\r\n\r\n    /**\r\n     * Decrypts encrypted private key with supplied password.\r\n     *\r\n     * @param keyphrase Password to decrypt with\r\n     * @param address For aad in decryption\r\n     * @param 16 secure random bytes\r\n     */\r\n    decrypt(keyphrase: string, address: Address, salt: string, n?: number): PrivateKey {\r\n        if (salt.length === 24 && isBase64(salt)) {\r\n            salt = Buffer.from(salt, 'base64').toString('hex');\r\n        }\r\n        let params;\r\n        if (!n) {\r\n            params = DEFAULT_SCRYPT;\r\n        } else {\r\n            params = {\r\n                cost: n,\r\n                blockSize: 8,\r\n                parallel: 8,\r\n                size: 64\r\n            };\r\n        }\r\n        const decrypted = decryptWithGcm(this.key, address, salt, keyphrase, params);\r\n        const decryptedKey = new PrivateKey(decrypted, this.algorithm, this.parameters);\r\n        const pk = decryptedKey.getPublicKey();\r\n        const addrTmp = Address.fromPubKey(pk);\r\n        if (addrTmp.toBase58() !== address.toBase58()) {\r\n            throw ERROR_CODE.Decrypto_ERROR;\r\n        }\r\n        return decryptedKey;\r\n    }\r\n\r\n    /**\r\n     * Encrypts private key with supplied password.\r\n     *\r\n     * @param keyphrase Password to encrypt with\r\n     * @param address For aad in encryption\r\n     * @param salt 16 secure random bytes\r\n     */\r\n    encrypt(keyphrase: string, address: Address, salt: string, n?: number): PrivateKey {\r\n        const publicKey = this.getPublicKey();\r\n        const addr = Address.fromPubKey(publicKey).toBase58();\r\n        if (addr !== address.toBase58()) {\r\n            throw ERROR_CODE.INVALID_ADDR;\r\n        }\r\n        let params;\r\n        if (!n) {\r\n            params = DEFAULT_SCRYPT;\r\n        } else {\r\n            params = {\r\n                cost: n,\r\n                blockSize: 8,\r\n                parallel: 8,\r\n                size: 64\r\n            };\r\n        }\r\n        const encrypted = encryptWithGcm(this.key, address, salt, keyphrase, params);\r\n        return new PrivateKey(encrypted, this.algorithm, this.parameters);\r\n    }\r\n\r\n    /**\r\n     * Signs the data with supplied private key using signature schema.\r\n     *\r\n     * If the signature schema is not provided, the default schema for this key type is used.\r\n     *\r\n     * This method is not suitable, if external keys (Ledger, TPM, ...) support is required.\r\n     *\r\n     * @param msg Hex encoded input data or Signable object\r\n     * @param schema Signing schema to use\r\n     * @param publicKeyId Id of public key\r\n     */\r\n    sign(msg: string | Signable, schema?: SignatureScheme, publicKeyId?: string): Signature {\r\n        if (schema === undefined) {\r\n            schema = this.algorithm.defaultSchema;\r\n        }\r\n\r\n        if (!this.isSchemaSupported(schema)) {\r\n            throw new Error('Signature schema does not match key type.');\r\n        }\r\n\r\n        // retrieves content to sign if not provided directly\r\n        if (typeof msg !== 'string') {\r\n            msg = msg.getSignContent();\r\n        }\r\n\r\n        let hash: string;\r\n        if (schema === SignatureScheme.SM2withSM3) {\r\n            // library sm.js (SM2withSM3) has implemented hashing as part of signing, therefore it is skipped\r\n            hash = msg;\r\n        } else {\r\n            hash = this.computeHash(msg, schema);\r\n        }\r\n\r\n        const signed = this.computeSignature(hash, schema);\r\n        return new Signature(schema, signed, publicKeyId);\r\n    }\r\n\r\n    /**\r\n     * Computes signature of message hash using specified signature schema.\r\n     *\r\n     * @param hash Message hash\r\n     * @param schema Signature schema to use\r\n     */\r\n    computeSignature(hash: string, schema: SignatureScheme): string {\r\n        switch (schema) {\r\n            case SignatureScheme.ECDSAwithSHA224:\r\n            case SignatureScheme.ECDSAwithSHA256:\r\n            case SignatureScheme.ECDSAwithSHA384:\r\n            case SignatureScheme.ECDSAwithSHA512:\r\n            case SignatureScheme.ECDSAwithSHA3_224:\r\n            case SignatureScheme.ECDSAwithSHA3_256:\r\n            case SignatureScheme.ECDSAwithSHA3_384:\r\n            case SignatureScheme.ECDSAwithSHA3_512:\r\n            case SignatureScheme.ECDSAwithRIPEMD160:\r\n                return this.computeEcDSASignature(hash);\r\n            case SignatureScheme.EDDSAwithSHA512:\r\n                return this.computeEdDSASignature(hash);\r\n            // case SignatureScheme.SM2withSM3:\r\n            //     return this.computeSM2Signature(hash);\r\n            default:\r\n                throw new Error('Unsupported signature schema.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes EcDSA signature of message hash. Curve name is derrived from private key.\r\n     *\r\n     * @param hash Message hash\r\n     */\r\n    computeEcDSASignature(hash: string): string {\r\n        const ec = new elliptic.ec(this.parameters.curve.preset);\r\n        const signed = ec.sign(hash, this.key, { canonical: true });\r\n        return Buffer.concat([\r\n            signed.r.toArrayLike(Buffer, 'be', 32),\r\n            signed.s.toArrayLike(Buffer, 'be', 32)\r\n        ]).toString('hex');\r\n    }\r\n\r\n    /**\r\n     * Computes EdDSA signature of message hash. Curve name is derrived from private key.\r\n     *\r\n     * @param hash Message hash\r\n     */\r\n    computeEdDSASignature(hash: string): string {\r\n        const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\r\n        const signed = eddsa.sign(hash, this.key, null);\r\n        return Buffer.concat([\r\n            signed.R.toArrayLike(Buffer, 'be', 32),\r\n            signed.S.toArrayLike(Buffer, 'be', 32)\r\n        ]).toString('hex');\r\n    }\r\n\r\n}\r\n"],"sourceRoot":""}]}