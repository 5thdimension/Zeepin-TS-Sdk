{"remainingRequest":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js??ref--13-2!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\scrypt.ts","dependencies":[{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\scrypt.ts","mtime":1601302458200},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport * as asyncScrypt from 'scrypt-async'; //import asyncScrypt from './scrypt-async.min.js';\n\nimport { createCipheriv, createDecipheriv } from 'crypto';\nimport { ERROR_CODE } from \"../common/error\";\nimport { hexstring2ab, isHexString } from \"../common/functionsUtils\";\n/**\r\n * Synchronious call to scrypt-async-js.\r\n *\r\n * @param keyphrase Keyphrase to use\r\n * @param addressHash Hex encoded address\r\n * @param params Scrypt params\r\n */\n\nfunction scrypt(keyphrase, addressHash, params) {\n  var derived = [];\n  asyncScrypt(keyphrase.normalize('NFC'), hexstring2ab(addressHash), {\n    N: params.cost,\n    r: params.blockSize,\n    p: params.parallel,\n    dkLen: params.size\n  }, function (result) {\n    derived = result;\n  });\n  return new Buffer(derived);\n}\n/**\r\n * Encrypt with aes-gcm-256\r\n * This is the default encryption algorithm for private key\r\n * @param privateKey Private key to encpryt with\r\n * @param address Adderss to encrypt with\r\n * @param salt Salt to encrypt with\r\n * @param keyphrase User's password\r\n * @param scryptParams Optional params to encrypt\r\n */\n\n\nexport function encryptWithGcm(privateKey, address, salt, keyphrase, scryptParams) {\n  if (!isHexString(privateKey)) {\n    throw new Error(ERROR_CODE.INVALID_PARAMS + ', Invalid private key');\n  }\n\n  var derived = scrypt(keyphrase, salt, scryptParams);\n  var derived1 = derived.slice(0, 12);\n  var derived2 = derived.slice(32);\n  var key = derived2;\n  var iv = derived1;\n  var aad = new Buffer(address.toBase58());\n  var cipher = createCipheriv('aes-256-gcm', key, iv);\n  cipher.setAAD(aad);\n  var plainText = Buffer.from(privateKey, 'hex');\n  var ciphertext = cipher.update(plainText);\n  var final = cipher.final();\n  var authTag = cipher.getAuthTag();\n  ciphertext = Buffer.concat([ciphertext, final]);\n  var result = Buffer.concat([ciphertext, authTag]);\n  return result.toString('base64');\n}\n/**\r\n * Decrypt with aes-256-gcm\r\n * @param encrypted Encrypted private key\r\n * @param address Address to decrypt with\r\n * @param salt Salt to decrypt with\r\n * @param keyphrase User's password\r\n * @param scryptParams Optioanl params to decrypt with\r\n */\n\nexport function decryptWithGcm(encrypted, address, salt, keyphrase, scryptParams) {\n  if (salt.length !== 32) {\n    throw ERROR_CODE.INVALID_PARAMS;\n  }\n\n  var result = Buffer.from(encrypted, 'base64');\n  var ciphertext = result.slice(0, result.length - 16);\n  var authTag = result.slice(result.length - 16);\n  var derived = scrypt(keyphrase, salt, scryptParams);\n  var derived1 = derived.slice(0, 12);\n  var derived2 = derived.slice(32);\n  var key = derived2;\n  var iv = derived1;\n  var aad = new Buffer(address.toBase58()); // const auth = new Buffer(authTag, 'hex');\n\n  var decipher = createDecipheriv('aes-256-gcm', key, iv);\n  decipher.setAAD(aad);\n  decipher.setAuthTag(authTag);\n  var decrypted = decipher.update(ciphertext).toString('hex');\n\n  try {\n    decrypted += decipher.final().toString('hex');\n  } catch (err) {\n    throw ERROR_CODE.Decrypto_ERROR;\n  }\n\n  return decrypted;\n}",{"version":3,"sources":["C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\scrypt.ts"],"names":[],"mappings":"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","sourcesContent":["import * as asyncScrypt from 'scrypt-async';\r\n//import asyncScrypt from './scrypt-async.min.js';\r\nimport { createCipheriv, createDecipheriv } from 'crypto';\r\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\r\nimport { ERROR_CODE } from \"../common/error\";\r\nimport { hexstring2ab, isHexString } from \"../common/functionsUtils\";\r\nimport { Address } from \"../wallet/address\";\r\n\r\n\r\nexport interface ScryptParams {\r\n    cost: number;\r\n    blockSize: number;\r\n    parallel: number;\r\n    size: number;\r\n}\r\n\r\n/**\r\n * Synchronious call to scrypt-async-js.\r\n *\r\n * @param keyphrase Keyphrase to use\r\n * @param addressHash Hex encoded address\r\n * @param params Scrypt params\r\n */\r\nfunction scrypt(keyphrase: string, addressHash: string, params: ScryptParams) {\r\n    let derived: number[] = [];\r\n    asyncScrypt(\r\n        keyphrase.normalize('NFC'),\r\n        hexstring2ab(addressHash),\r\n        {\r\n            N: params.cost,\r\n            r: params.blockSize,\r\n            p: params.parallel,\r\n            dkLen: params.size\r\n        },\r\n        (result: string | number[]) => {\r\n            derived = result as number[];\r\n        }\r\n    );\r\n    return new Buffer(derived);\r\n}\r\n\r\n/**\r\n * Encrypt with aes-gcm-256\r\n * This is the default encryption algorithm for private key\r\n * @param privateKey Private key to encpryt with\r\n * @param address Adderss to encrypt with\r\n * @param salt Salt to encrypt with\r\n * @param keyphrase User's password\r\n * @param scryptParams Optional params to encrypt\r\n */\r\nexport function encryptWithGcm(\r\n    privateKey: string,\r\n    address: Address,\r\n    salt: string,\r\n    keyphrase: string,\r\n    scryptParams: ScryptParams\r\n) {\r\n    if (!isHexString(privateKey)) {\r\n        throw new Error(ERROR_CODE.INVALID_PARAMS + ', Invalid private key');\r\n    }\r\n    const derived = scrypt(keyphrase, salt, scryptParams);\r\n    const derived1 = derived.slice(0, 12);\r\n    const derived2 = derived.slice(32);\r\n    const key = derived2;\r\n    const iv = derived1;\r\n    const aad = new Buffer(address.toBase58());\r\n    const cipher = createCipheriv('aes-256-gcm', key, iv);\r\n    cipher.setAAD(aad);\r\n    const plainText = Buffer.from(privateKey, 'hex');\r\n    let ciphertext = cipher.update(plainText);\r\n    const final = cipher.final();\r\n    const authTag = cipher.getAuthTag();\r\n    ciphertext = Buffer.concat([ciphertext, final]);\r\n\r\n    const result = Buffer.concat([ciphertext, authTag]);\r\n    return result.toString('base64');\r\n}\r\n\r\n/**\r\n * Decrypt with aes-256-gcm\r\n * @param encrypted Encrypted private key\r\n * @param address Address to decrypt with\r\n * @param salt Salt to decrypt with\r\n * @param keyphrase User's password\r\n * @param scryptParams Optioanl params to decrypt with\r\n */\r\nexport function decryptWithGcm(\r\n    encrypted: string,\r\n    address: Address,\r\n    salt: string,\r\n    keyphrase: string,\r\n    scryptParams: ScryptParams\r\n) {\r\n    if (salt.length !== 32) {\r\n        throw ERROR_CODE.INVALID_PARAMS;\r\n    }\r\n    const result = Buffer.from(encrypted, 'base64');\r\n    const ciphertext = result.slice(0, result.length - 16);\r\n    const authTag = result.slice(result.length - 16);\r\n    const derived = scrypt(keyphrase, salt, scryptParams);\r\n    const derived1 = derived.slice(0, 12);\r\n    const derived2 = derived.slice(32);\r\n    const key = derived2;\r\n    const iv = derived1;\r\n    const aad = new Buffer(address.toBase58());\r\n    // const auth = new Buffer(authTag, 'hex');\r\n    const decipher = createDecipheriv('aes-256-gcm', key, iv);\r\n    decipher.setAAD(aad);\r\n    decipher.setAuthTag(authTag);\r\n    let decrypted = decipher.update(ciphertext).toString('hex');\r\n    try {\r\n        decrypted += decipher.final().toString('hex');\r\n    } catch (err) {\r\n        throw ERROR_CODE.Decrypto_ERROR;\r\n    }\r\n    return decrypted;\r\n}\r\n\r\n"],"sourceRoot":""}]}