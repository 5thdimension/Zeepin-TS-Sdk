{"remainingRequest":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js??ref--13-2!C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\programs.ts","dependencies":[{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\programs.ts","mtime":1601302458193},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\node_modules\\ts-loader\\index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import _classCallCheck from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _parseInt from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/parse-int\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _getIterator from \"C:\\\\Users\\\\Jesse\\\\Documents\\\\GitHub\\\\Zeepin-TS-Sdk\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/get-iterator\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.number.constructor\";\nimport * as elliptic from 'elliptic';\nimport { BigInt } from \"../common/classesUtils\";\nimport { StringReader } from \"../common/classesUtils\";\nimport { PublicKey } from \"./publicKey\";\nimport opcode from \"../common/opCode\";\nimport { num2hexstring } from \"../common/functionsUtils\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { KeyType } from \"./cryptoParams\";\nexport function comparePublicKeys(a, b) {\n  if (a.algorithm !== b.algorithm) {\n    return a.algorithm.hex - b.algorithm.hex;\n  }\n\n  switch (a.algorithm) {\n    case KeyType.ECDSA:\n      var ec = new elliptic.ec(a.parameters.curve.preset);\n      var paKey = ec.keyFromPublic(a.key, 'hex', true);\n      var pbKey = ec.keyFromPublic(b.key, 'hex', true);\n      var pa = paKey.getPublic();\n      var pb = pbKey.getPublic();\n\n      if (pa.getX() !== pb.getX()) {\n        return pa.getX() - pb.getX();\n      } else {\n        return pa.getY() - pb.getY();\n      }\n\n    case KeyType.EDDSA:\n      return Number(a.key) - Number(b.key);\n\n    default:\n      return 0;\n  }\n}\nexport function programFromPubKey(pk) {\n  var result = '';\n  result += pushPubKey(pk);\n  result += pushOpCode(opcode.CHECKSIG);\n  return result;\n}\nexport function programFromMultiPubKey(pubkeys, m) {\n  var n = pubkeys.length;\n\n  if (!(1 <= m && m <= n && n <= 1024)) {\n    throw new Error('Wrong multi-sig param');\n  }\n\n  pubkeys.sort(comparePublicKeys);\n  var result = '';\n  result += pushNum(m);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(pubkeys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var pk = _step.value;\n      result += pushBytes(pk.serializeHex());\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  result += pushNum(n);\n  result += pushOpCode(opcode.CHECKMULTISIG);\n  return result;\n}\nexport function pushNum(num) {\n  if (num === 0) {\n    return pushOpCode(opcode.PUSH0);\n  } else if (num <= 16) {\n    return num2hexstring(num - 1 + opcode.PUSH1);\n  }\n\n  var bint = new BigInt(num.toString());\n  return pushBytes(bint.toHexstr());\n}\nexport function pushPubKey(pk) {\n  var pkStr = pk.serializeHex();\n  return pushBytes(pkStr);\n}\nexport function pushOpCode(op) {\n  return num2hexstring(op);\n}\nexport function pushBytes(hexstr) {\n  var result = '';\n\n  if (hexstr.length === 0) {\n    throw new Error('pushBytes error, hexstr is empty.');\n  }\n\n  var len = hexstr.length / 2;\n\n  if (len <= opcode.PUSHBYTES75 + 1 - opcode.PUSHBYTES1) {\n    result += num2hexstring(len + opcode.PUSHBYTES1 - 1);\n  } else if (len < 0x100) {\n    result += num2hexstring(opcode.PUSHDATA1);\n    result += num2hexstring(len);\n  } else if (len < 0x10000) {\n    result += num2hexstring(opcode.PUSHDATA2);\n    result += num2hexstring(len, 2, true);\n  } else if (len < 0x100000000) {\n    result += num2hexstring(opcode.PUSHDATA4);\n    result += num2hexstring(len, 4, true);\n  } else {\n    throw ERROR_CODE.INVALID_PARAMS;\n  }\n\n  result += hexstr;\n  return result;\n}\nexport function readOpcode(sr) {\n  return _parseInt(sr.read(1), 16);\n}\nexport function readBytes(sr) {\n  var code = readOpcode(sr);\n  var keylen;\n\n  if (code === opcode.PUSHDATA4) {\n    keylen = sr.readUint32();\n  } else if (code === opcode.PUSHDATA2) {\n    keylen = sr.readUint16();\n  } else if (code === opcode.PUSHDATA1) {\n    keylen = sr.readUint8();\n  } else if (code <= opcode.PUSHBYTES75 && code >= opcode.PUSHBYTES1) {\n    keylen = code - opcode.PUSHBYTES1 + 1;\n  } else {\n    throw new Error('unexpected opcode: ' + code);\n  }\n\n  return sr.read(keylen);\n}\nexport function getParamsFromProgram(hexstr) {\n  var sigs = [];\n  var sr = new StringReader(hexstr);\n\n  while (!sr.isEmpty()) {\n    sigs.push(readBytes(sr));\n  }\n\n  return sigs;\n}\nexport var ProgramInfo = function ProgramInfo() {\n  _classCallCheck(this, ProgramInfo);\n\n  this.M = 0;\n  this.pubKeys = [];\n};\nexport function readPubKey(sr) {\n  var pkStr = sr.readNextBytes();\n  return PublicKey.deserializeHex(new StringReader(pkStr));\n}\nexport function getProgramInfo(hexstr) {\n  var info = new ProgramInfo();\n\n  var end = _parseInt(hexstr.substr(-2, 2), 16);\n\n  if (end === opcode.CHECKSIG) {\n    var sr = new StringReader(hexstr);\n    var pk = readPubKey(sr);\n    info.M = 1;\n    info.pubKeys = [pk];\n    return info;\n  } else if (end === opcode.CHECKMULTISIG) {\n    var _sr = new StringReader(hexstr);\n\n    var m = _parseInt(_sr.read(1), 16) - opcode.PUSH1 + 1;\n    var n = _parseInt(hexstr.substr(-4, 2), 16) - opcode.PUSH1 + 1;\n    info.M = m;\n    info.pubKeys = [];\n\n    for (var i = 0; i < n; i++) {\n      var key = readPubKey(_sr);\n      info.pubKeys.push(key);\n    } // const n = readNum(sr);\n\n\n    return info;\n  } else {\n    throw new Error('Unsupported program.');\n  }\n}\nexport function programFromParams(sigs) {\n  var result = '';\n  sigs.sort();\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = _getIterator(sigs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var s = _step2.value;\n      result += pushBytes(s);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n}",{"version":3,"sources":["C:\\Users\\Jesse\\Documents\\GitHub\\Zeepin-TS-Sdk\\packages\\sdk\\crypto\\programs.ts"],"names":[],"mappings":"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","sourcesContent":["import * as elliptic from 'elliptic';\r\nimport { BigInt } from \"../common/classesUtils\";\r\nimport { StringReader } from \"../common/classesUtils\";\r\nimport { PublicKey } from \"./publicKey\";\r\nimport opcode from \"../common/opCode\";\r\nimport { num2hexstring } from \"../common/functionsUtils\";\r\nimport { ERROR_CODE } from \"../common/error\";\r\nimport { KeyType } from \"./cryptoParams\";\r\n\r\nexport function comparePublicKeys(a: PublicKey, b: PublicKey) {\r\n    if (a.algorithm !== b.algorithm) {\r\n        return a.algorithm.hex - b.algorithm.hex;\r\n    }\r\n    switch (a.algorithm) {\r\n        case KeyType.ECDSA:\r\n            const ec = new elliptic.ec(a.parameters.curve.preset);\r\n            const paKey = ec.keyFromPublic(a.key, 'hex', true);\r\n            const pbKey = ec.keyFromPublic(b.key, 'hex', true);\r\n            const pa = paKey.getPublic();\r\n            const pb = pbKey.getPublic();\r\n            if (pa.getX() !== pb.getX()) {\r\n                return pa.getX() - pb.getX();\r\n            } else {\r\n                return pa.getY() - pb.getY();\r\n            }\r\n        case KeyType.EDDSA:\r\n            return Number(a.key) - Number(b.key);\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\nexport function programFromPubKey(pk: PublicKey): string {\r\n    let result = '';\r\n    result += pushPubKey(pk);\r\n    result += pushOpCode(opcode.CHECKSIG);\r\n    return result;\r\n}\r\n\r\nexport function programFromMultiPubKey(pubkeys: PublicKey[], m: number): string {\r\n    const n = pubkeys.length;\r\n    if (!(1 <= m && m <= n && n <= 1024)) {\r\n        throw new Error('Wrong multi-sig param');\r\n    }\r\n\r\n    pubkeys.sort(comparePublicKeys);\r\n\r\n    let result = '';\r\n    result += pushNum(m);\r\n\r\n    for (const pk of pubkeys) {\r\n        result += pushBytes(pk.serializeHex());\r\n    }\r\n    result += pushNum(n);\r\n    result += pushOpCode(opcode.CHECKMULTISIG);\r\n    return result;\r\n}\r\n\r\nexport function pushNum(num: number): string {\r\n    if ( num === 0 ) {\r\n        return pushOpCode(opcode.PUSH0);\r\n    } else if ( num <= 16 ) {\r\n        return num2hexstring(num - 1 + opcode.PUSH1);\r\n    }\r\n    const bint = new BigInt(num.toString());\r\n    return pushBytes(bint.toHexstr());\r\n}\r\n\r\nexport function pushPubKey(pk: PublicKey): string {\r\n    const pkStr = pk.serializeHex();\r\n    return pushBytes(pkStr);\r\n}\r\n\r\nexport function pushOpCode(op: opcode): string {\r\n    return num2hexstring(op);\r\n}\r\n\r\nexport function pushBytes(hexstr: string): string {\r\n    let result = '';\r\n    if (hexstr.length === 0) {\r\n        throw new Error('pushBytes error, hexstr is empty.');\r\n    }\r\n    const len = hexstr.length / 2;\r\n    if (len <= opcode.PUSHBYTES75 + 1 - opcode.PUSHBYTES1 ) {\r\n        result += num2hexstring(len + opcode.PUSHBYTES1 - 1);\r\n    } else if (len < 0x100) {\r\n        result += num2hexstring(opcode.PUSHDATA1);\r\n        result += num2hexstring(len);\r\n    } else if (len < 0x10000) {\r\n        result += num2hexstring(opcode.PUSHDATA2);\r\n        result += num2hexstring(len, 2, true);\r\n    } else if (len < 0x100000000) {\r\n        result += num2hexstring(opcode.PUSHDATA4);\r\n        result += num2hexstring(len, 4, true);\r\n    } else {\r\n        throw ERROR_CODE.INVALID_PARAMS;\r\n    }\r\n    result += hexstr;\r\n    return result;\r\n}\r\n\r\nexport function readOpcode(sr: StringReader) {\r\n    return parseInt(sr.read(1), 16);\r\n}\r\n\r\nexport function readBytes(sr: StringReader) {\r\n    const code = readOpcode(sr);\r\n    let keylen;\r\n    if (code === opcode.PUSHDATA4) {\r\n        keylen = sr.readUint32();\r\n    } else if (code === opcode.PUSHDATA2) {\r\n        keylen = sr.readUint16();\r\n    } else if (code === opcode.PUSHDATA1) {\r\n        keylen = sr.readUint8();\r\n    } else if (code <= opcode.PUSHBYTES75 && code >= opcode.PUSHBYTES1) {\r\n        keylen = code - opcode.PUSHBYTES1 + 1;\r\n    } else {\r\n        throw new Error('unexpected opcode: ' + code);\r\n    }\r\n    return sr.read(keylen);\r\n}\r\n\r\nexport function getParamsFromProgram(hexstr: string): string[] {\r\n    const sigs:string[] = [];\r\n    const sr = new StringReader(hexstr);\r\n    while (!sr.isEmpty()) {\r\n        sigs.push(readBytes(sr));\r\n    }\r\n    return sigs;\r\n}\r\n\r\n\r\nexport class ProgramInfo {\r\n    M: number = 0;\r\n    pubKeys: PublicKey[] = [];\r\n}\r\n\r\nexport function readPubKey(sr: StringReader) {\r\n    const pkStr = sr.readNextBytes();\r\n    return PublicKey.deserializeHex(new StringReader(pkStr));\r\n}\r\n\r\nexport function getProgramInfo(hexstr: string): ProgramInfo {\r\n    const info = new ProgramInfo();\r\n    const end = parseInt(hexstr.substr(-2, 2), 16);\r\n    if (end === opcode.CHECKSIG) {\r\n        const sr = new StringReader(hexstr);\r\n        const pk = readPubKey(sr);\r\n        info.M = 1;\r\n        info.pubKeys = [pk];\r\n        return info;\r\n    } else if (end === opcode.CHECKMULTISIG) {\r\n        const sr = new StringReader(hexstr);\r\n        const m = parseInt(sr.read(1), 16) - opcode.PUSH1 + 1;\r\n        const n = parseInt(hexstr.substr(-4, 2), 16) - opcode.PUSH1 + 1;\r\n        info.M = m;\r\n        info.pubKeys = [];\r\n        for (let i = 0; i < n; i++) {\r\n            const key = readPubKey(sr);\r\n            info.pubKeys.push(key);\r\n        }\r\n        // const n = readNum(sr);\r\n        return info;\r\n    } else {\r\n        throw new Error('Unsupported program.');\r\n    }\r\n}\r\n\r\nexport function programFromParams(sigs: string[]): string {\r\n    let result = '';\r\n    sigs.sort();\r\n    for ( const s of sigs) {\r\n        result += pushBytes(s);\r\n    }\r\n    return result;\r\n}\r\n\r\n"],"sourceRoot":""}]}